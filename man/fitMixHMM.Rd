% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/fitMixHMM.R
\name{fitMixHMM}
\alias{fitMixHMM}
\title{Estimate Parameters of Mixture Hidden Markov Model}
\usage{
fitMixHMM(model, use.em = TRUE, use.nloptr = TRUE, lb, ub, shrink = FALSE,
  em.control = list(), soft = TRUE, maxeval = 10000,
  nloptr.control = list(), ...)
}
\arguments{
\item{model}{Hidden Markov model of class \code{mixHMModel}.}

\item{use.em}{Logical, use EM algorithm at the start of parameter estimation.
Default is FALSE. Note that EM algorithm is faster than direct numerical optimization, but is even more prone to get stuck in local optimum.}

\item{use.nloptr}{Logical, use direct numerical optimization via
\code{\link{nloptr}} (possibly after the EM algorithm). Default is TRUE.}

\item{lb,}{ub Lower and upper bounds for parameters in Softmax parameterization.
Default interval is [min(-10,initialvalues), max(10,initialvalues)] which is widened according the initial values of parameters, if necessary.}

\item{shrink}{instead of adjusting the bounds of optimization, adjust the initial values so that
they fit inside the intervals i.e. \code{initialvalues[initiavalues<lb] <- lb} and similarly for upper bounds. Default is TRUE.#'}

\item{em.control}{Optional list of control parameters for for EM algorithm.
Possible arguments are \describe{
\item{maxit}{Maximum number of iterations, default is 100.}
\item{trace}{Level of printing. Possible values are 0
(prints nothing), 1 (prints information at start and end of algorithm), and
2 (prints at every iteration).}
\item{reltol}{Relative tolerance for convergence defined as \eqn{(sumLogLikNew - sumLogLikOld)/(abs(sumLogLikOld)+0.1)}.
Default is 1e-8.} }}

\item{nloptr.control}{Optional list of additional arguments for
  \code{\link{nloptr}} argument \code{opts}. Default values are
  \describe{
   \item{algorithm}{\code{"NLOPT_GD_MLSL"}}
\item{local_opts}{\code{list(algorithm = "NLOPT_LD_LBFGS",  xtol_rel = 1e-4, ftol_rel = 1e-8)}}
\item{ranseed}{\code{123}}
\item{maxeval}{\code{10000} (maximum number of iterations in global optimization algorithm)}
\item{maxtime}{\code{600} (maximum run time in seconds)}
}}

\item{...}{Additional arguments to nloptr}
}
\value{
List with components \item{model}{Estimated model. }
  \item{logLik}{Log-likelihood of the estimated model. }
  \item{em.results}{Results from EM algorithm. }
  \item{nloptr.results}{Results from direct numerical optimization via
  \code{\link{nloptr}}. }
}
\description{
Function \code{fitMixHMM} estimates a mixture of hidden Markov models
using numerical maximization of log-likelihood. Initial values for estimation
are taken from the corresponding components of the model with preservation of
original zero probabilities.
}
\examples{
\dontrun{
require(TraMineR)

data(biofam)
biofam <- biofam[complete.cases(biofam[c(2:4)]),]
biofam <- biofam[1:500,]

## Building one channel per type of event left, children or married
bf <- as.matrix(biofam[, 10:25])
children <-  bf==4 | bf==5 | bf==6
married <- bf == 2 | bf== 3 | bf==6
left <- bf==1 | bf==3 | bf==5 | bf==6 | bf==7

children[children==TRUE] <- "Children"
children[children==FALSE] <- "Childless"
# Divorced parents
div <- bf[(rowSums(bf==7)>0 & rowSums(bf==5)>0) |
            (rowSums(bf==7)>0 & rowSums(bf==6)>0),]
children[rownames(bf) \%in\% rownames(div) & bf==7] <- "Children"

married[married==TRUE] <- "Married"
married[married==FALSE] <- "Single"
married[bf==7] <- "Divorced"

left[left==TRUE] <- "Left home"
left[left==FALSE] <- "With parents"
# Divorced living with parents (before divorce)
wp <- bf[(rowSums(bf==7)>0 & rowSums(bf==2)>0 & rowSums(bf==3)==0 &
          rowSums(bf==5)==0 & rowSums(bf==6)==0) |
           (rowSums(bf==7)>0 & rowSums(bf==4)>0 & rowSums(bf==3)==0 &
          rowSums(bf==5)==0 & rowSums(bf==6)==0),]
left[rownames(bf) \%in\% rownames(wp) & bf==7] <- "With parents"

## Building sequence objects
child.seq <- seqdef(children, start=15)
marr.seq <- seqdef(married, start=15)
left.seq <- seqdef(left, start=15)

## Starting values for emission probabilities

# Cluster 1
alphabet(child.seq) # Checking for the order of observed states
B1_child <- matrix(c(0.99, 0.01, # High probability for childless
                     0.99, 0.01,
                     0.99, 0.01,
                     0.99, 0.01), nrow=4, ncol=2, byrow=TRUE)

alphabet(marr.seq)
B1_marr <- matrix(c(0.01, 0.01, 0.98, # High probability for single
                    0.01, 0.01, 0.98,
                    0.01, 0.98, 0.01, # High probability for married
                    0.98, 0.01, 0.01), # High probability for divorced
                    nrow=4, ncol=3, byrow=TRUE)

alphabet(left.seq)
B1_left <- matrix(c(0.01, 0.99, # High probability for living with parents
                    0.99, 0.01, # High probability for having left home
                    0.99, 0.01,
                    0.99, 0.01), nrow=4, ncol=2, byrow=TRUE)

# Cluster 2
B2_child <- matrix(c(0.99, 0.01, # High probability for childless
                     0.99, 0.01,
                     0.99, 0.01,
                     0.01, 0.99), nrow=4, ncol=2, byrow=TRUE)

B2_marr <- matrix(c(0.01, 0.01, 0.98, # High probability for single
                    0.01, 0.01, 0.98,
                    0.01, 0.98, 0.01, # High probability for married
                    0.29, 0.7, 0.01),
                   nrow=4, ncol=3, byrow=TRUE)

B2_left <- matrix(c(0.01, 0.99, # High probability for living with parents
                    0.99, 0.01,
                    0.99, 0.01,
                    0.99, 0.01), nrow=4, ncol=2, byrow=TRUE)

# Cluster 3
B3_child <- matrix(c(0.99, 0.01, # High probability for childless
                     0.99, 0.01,
                     0.01, 0.99,
                     0.99, 0.01,
                     0.01, 0.99,
                     0.01, 0.99), nrow=6, ncol=2, byrow=TRUE)

B3_marr <- matrix(c(0.01, 0.01, 0.98, # High probability for single
                    0.01, 0.01, 0.98,
                    0.01, 0.01, 0.98,
                    0.01, 0.98, 0.01,
                    0.01, 0.98, 0.01, # High probability for married
                    0.98, 0.01, 0.01), # High probability for divorced
                   nrow=6, ncol=3, byrow=TRUE)

B3_left <- matrix(c(0.01, 0.99, # High probability for living with parents
                    0.99, 0.01,
                    0.50, 0.50,
                    0.01, 0.99,
                    0.99, 0.01,
                    0.99, 0.01), nrow=6, ncol=2, byrow=TRUE)

# Initial values for transition matrices
A1 <- matrix(c(0.8,   0.16, 0.03, 0.01,
                 0,    0.9, 0.07, 0.03,
                 0,      0,  0.9,  0.1,
                 0,      0,    0,    1),
             nrow=4, ncol=4, byrow=TRUE)

A2 <- matrix(c(0.8, 0.10, 0.05,  0.03, 0.01, 0.01,
                 0,  0.7,  0.1,   0.1, 0.05, 0.05,
                 0,    0, 0.85,  0.01,  0.1, 0.04,
                 0,    0,    0,   0.9, 0.05, 0.05,
                 0,    0,    0,     0,  0.9,  0.1,
                 0,    0,    0,     0,    0,    1),
             nrow=6, ncol=6, byrow=TRUE)

# Initial values for initial state probabilities
initialProbs1 <- c(0.9, 0.07, 0.02, 0.01)
initialProbs2 <- c(0.9, 0.04, 0.03, 0.01, 0.01, 0.01)

# Creating covariate swiss
biofam$swiss <- biofam$nat_1_02=="Switzerland"
biofam$swiss[biofam$swiss==TRUE] <- "Swiss"
biofam$swiss[biofam$swiss==FALSE] <- "Other"

# Build mixture HMM
bmHMM <- buildMixHMM(observations=list(child.seq, marr.seq, left.seq),
                       transitionMatrix=list(A1,A1,A2),
                       emissionMatrix=list(list(B1_child, B1_marr, B1_left),
                                           list(B2_child, B2_marr, B2_left),
                                           list(B3_child, B3_marr, B3_left)),
                       initialProbs=list(initialProbs1, initialProbs1,
                                         initialProbs2),
                       formula=~sex*birthyr+sex*swiss, data=biofam,
                       clusterNames=c("Cluster 1", "Cluster 2", "Cluster 3"),
                       channelNames=c("Parenthood", "Marriage", "Left home"),
                       )

mHMM <- fitMixHMM(bmHMM)

# Coefficients of covariates
mHMM$model$beta

# Probabilities of belonging to each model for the first six subjects
head(mHMM$model$clusterProb)
}
}
\seealso{
\code{\link{buildMixHMM}} for building mixture HMM's;
\code{\link{buildHMM}} and \code{\link{fitHMM}} for building and
  fitting hidden Markov models without covariates; \code{\link{plot.mixHMModel}}
  for plotting \code{mixHMModel} objects and \code{\link{mssplot}} for plotting
  stacked sequence plots of \code{mixHMModel} objects.
}

