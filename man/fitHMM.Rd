% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/fitHMM.R
\name{fitHMM}
\alias{fitHMM}
\title{Estimate Parameters of Hidden Markov Model
Function \code{fitHMM} estimates the initial state, transition and emission
probabilities of hidden Markov model. Initial values for estimation are taken from the
corresponding components of the model with preservation of original zero
probabilities.}
\usage{
fitHMM(model, use.em = FALSE, use.nloptr = TRUE, lb, ub, shrink = FALSE,
  em.control = list(), soft = TRUE, maxeval = 10000,
  nloptr.control = list(), ...)
}
\arguments{
\item{model}{Hidden Markov model of class \code{HMModel}.}

\item{use.em}{Logical, use EM algorithm at the start of parameter estimation.
The default is \code{FALSE}. Note that EM algorithm is faster than direct
numerical optimization, but is even more prone to get stuck in local optimum.}

\item{use.nloptr}{Logical, use direct numerical optimization via
\code{\link{nloptr}} (possibly after the EM algorithm). The default is \code{TRUE}.}

\item{lb,ub}{Lower and upper bounds for parameters in Softmax parameterization.
Default interval is [min(-10,initialvalues), max(10,initialvalues)] which is widened according the initial values of parameters,
  if necessary.}

\item{shrink}{instead of adjusting the bounds of optimization, adjust the initial
values so that they fit inside the intervals i.e.
\code{initialvalues[initiavalues<lb] <- lb} and similarly for upper bounds.
The default is \code{TRUE}.}

\item{em.control}{Optional list of control parameters for for EM algorithm.
Possible arguments are \describe{
\item{maxit}{Maximum number of iterations, default is 100.}
\item{trace}{Level of printing. Possible values are 0
(prints nothing), 1 (prints information at start and end of algorithm), and
2 (prints at every iteration).}
\item{reltol}{Relative tolerance for convergence defined as \eqn{(sumLogLikNew - sumLogLikOld)/(abs(sumLogLikOld)+0.1)}.
Default is 1e-8.} }}

\item{nloptr.control}{Optional list of additional arguments for
  \code{\link{nloptr}} argument \code{opts}. Default values are
  \describe{
   \item{algorithm}{\code{"NLOPT_GD_MLSL"}}
\item{local_opts}{\code{list(algorithm = "NLOPT_LD_LBFGS",  xtol_rel = 1e-4, ftol_rel = 1e-8)}}
\item{ranseed}{\code{123}}
\item{maxeval}{\code{10000} (maximum number of iterations in global optimization algorithm)}
\item{maxtime}{\code{600} (maximum run time in seconds)}
}}

\item{...}{Additional arguments to nloptr}
}
\value{
List with components \item{model}{Estimated model. }
  \item{logLik}{Log-likelihood of the estimated model. }
  \item{em.results}{Results from EM algorithm. }
  \item{nloptr.results}{Results from direct numerical optimization via
  \code{\link{nloptr}}. }
}
\description{
By default, estimation start with EM algorithm and then switches to direct
numerical maximization.
}
\details{
By default the fitHMM function uses only the \code{nloptr} function which
  uses the multilevel single linkage method for global optimization
  (\code{NLOPT_GD_MLSL} as \code{algorithm} in \code{nloptr.control}). It performs
  a sequence of local optimizations from random starting points, by default using
  the BFGS algorithm (\code{NLOPT_LD_LBFGS} as \code{local_opts} in
  \code{nloptr.control}). The user can set the maximum number of evaluations or
  limit the time used for the optimization.
}
\examples{
require(TraMineR)

data(biofam)
biofam <- biofam[1:500,]

## Building one channel per type of event left, children or married
bf <- as.matrix(biofam[, 10:25])
children <-  bf == 4 | bf == 5 | bf == 6
married <- bf == 2 | bf == 3 | bf == 6
left <- bf == 1 | bf == 3 | bf == 5 | bf == 6

children[children == TRUE] <- "Children"
children[children == FALSE] <- "Childless"

married[married == TRUE] <- "Married"
married[married == FALSE] <- "Single"

left[left == TRUE] <- "Left home"
left[left == FALSE] <- "With parents"

## Building sequence objects
child.seq <- seqdef(children)
marr.seq <- seqdef(married)
left.seq <- seqdef(left)

# Initial values for emission matrices
B_child <- matrix(NA, nrow = 3, ncol = 2)
B_child[1,] <- seqstatf(child.seq[, 1:5])[, 2] + 0.1
B_child[2,] <- seqstatf(child.seq[, 6:10])[, 2] + 0.1
B_child[3,] <- seqstatf(child.seq[, 11:15])[, 2] + 0.1
B_child <- B_child / rowSums(B_child)

B_marr <- matrix(NA, nrow=3, ncol=2)
B_marr[1,] <- seqstatf(marr.seq[, 1:5])[, 2] + 0.1
B_marr[2,] <- seqstatf(marr.seq[, 6:10])[, 2] + 0.1
B_marr[3,] <- seqstatf(marr.seq[, 11:15])[, 2] + 0.1
B_marr <- B_marr / rowSums(B_marr)

B_left <- matrix(NA, nrow = 3, ncol = 2)
B_left[1,] <- seqstatf(left.seq[, 1:5])[, 2] + 0.1
B_left[2,] <- seqstatf(left.seq[, 6:10])[, 2] + 0.1
B_left[3,] <- seqstatf(left.seq[, 11:15])[, 2] + 0.1
B_left <- B_left / rowSums(B_left)

# Initial values for transition matrix
A <- matrix(c(0.9, 0.07, 0.03,
                0,  0.9,  0.1,
                0,    0,    1), nrow = 3, ncol = 3, byrow = TRUE)

# Initial values for initial state probabilities
initialProbs <- c(0.9, 0.09, 0.01)

# Building hidden Markov model with initial parameter values
bHMM <- buildHMM(
  observations = list(child.seq, marr.seq, left.seq),
  transitionMatrix = A,
  emissionMatrix = list(B_child, B_marr, B_left),
  initialProbs = initialProbs)

# Fitting hidden Markov model
HMM <- fitHMM(bHMM)
}
\seealso{
\code{\link{buildHMM}} for building Hidden Markov models before
  fitting, \code{\link{trimHMM}} for finding better models by changing small
  parameter values to zero, \code{\link{BIC.HMModel}} for computing the
  value of the Bayesian information criterion of the model, and
  \code{\link{plot.HMModel}} and \code{\link{ssplot}} for plotting
  HMModel objects.
}

