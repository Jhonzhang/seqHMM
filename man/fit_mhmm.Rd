% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/fit_mhmm.R
\name{fit_mhmm}
\alias{fit_mhmm}
\title{Estimate Parameters of Mixture Hidden Markov Model}
\usage{
fit_mhmm(model, em_step = TRUE, global_step = TRUE, local_step = TRUE,
  em_control = list(), global_control = list(), local_control = list(),
  lb, ub, soft = TRUE, ...)
}
\arguments{
\item{model}{Hidden Markov model of class \code{mhmm}.}

\item{em_step}{Logical, use EM algorithm at the start of parameter estimation.
The default is \code{TRUE}. Note that EM algorithm is faster than direct numerical optimization,
but is even more prone to get stuck in a local optimum.}

\item{global_step}{Logical, use global optimization via
\code{\link{nloptr}} (possibly after the EM step). The default is \code{TRUE}.}

\item{local_step}{Logical, use local optimization via
\code{\link{nloptr}} (possibly after the EM and/or global steps). The default is \code{TRUE}.}

\item{em_control}{Optional list of control parameters for for EM algorithm.
Possible arguments are \describe{
\item{maxeval}{Maximum number of iterations, default is 100.}
\item{trace}{Level of printing. Possible values are 0
(prints nothing), 1 (prints information at start and end of algorithm), and
2 (prints at every iteration).}
\item{reltol}{Relative tolerance for convergence defined as \eqn{(sumLogLikNew - sumLogLikOld)/(abs(sumLogLikOld)+0.1)}.
Default is 1e-8.} }}

\item{global_control}{Optional list of additional arguments for
  \code{\link{nloptr}} argument \code{opts}. The default values are
  \describe{
   \item{algorithm}{\code{"NLOPT_GD_MLSL_LDS"}}
   \item{local_opts}{\code{list(algorithm = "NLOPT_LD_LBFGS",  xtol_rel = 1e-4)}}
   \item{ranseed}{\code{123}}
   \item{maxeval}{\code{10000} (maximum number of iterations in global optimization algorithm)}
   \item{maxtime}{\code{60} (maximum run time in seconds)}
}}

\item{local_control}{Optional list of additional arguments for
\code{\link{nloptr}} argument \code{opts}. The default values are
\describe{
 \item{algorithm}{\code{"NLOPT_LD_LBFGS"}}
 \item{xtol_rel}{\code{1e-8}}
 \item{maxeval}{\code{10000} (maximum number of iterations)}
 \item{maxtime}{\code{60} (maximum run time in seconds)}
}}

\item{lb,ub}{Lower and upper bounds for parameters in Softmax parameterization.
Default interval is [pmin(-10,2*initialvalues), pmax(10,2*initialvalues)]. Lower bound is used only in global optimization.}

\item{...}{Additional arguments to nloptr}
}
\value{
List with components \item{model}{Estimated model. }
  \item{logLik}{Log-likelihood of the estimated model. }
  \item{em_results}{Results after the EM step. }
  \item{global_results}{Results after the global step. }
  \item{local_results}{Results after the local step. }
}
\description{
Function \code{fit_mhmm} estimates a mixture of hidden Markov models
using numerical maximization of log-likelihood. Initial values for estimation
are taken from the corresponding components of the model with preservation of
original zero probabilities.
}
\examples{
\dontrun{
require(TraMineR)

data(biofam)
biofam <- biofam[complete.cases(biofam[c(2:4)]),]
biofam <- biofam[1:500,]

## Building one channel per type of event left, children or married
bf <- as.matrix(biofam[, 10:25])
children <-  bf == 4 | bf == 5 | bf == 6
married <- bf == 2 | bf == 3 | bf == 6
left <- bf == 1 | bf == 3 | bf == 5 | bf == 6 | bf == 7

children[children == TRUE] <- "Children"
children[children == FALSE] <- "Childless"
# Divorced parents
div <- bf[(rowSums(bf == 7) > 0 & rowSums(bf == 5) > 0) |
            (rowSums(bf == 7) > 0 & rowSums(bf == 6) > 0),]
children[rownames(bf) \%in\% rownames(div) & bf == 7] <- "Children"

married[married == TRUE] <- "Married"
married[married == FALSE] <- "Single"
married[bf == 7] <- "Divorced"

left[left == TRUE] <- "Left home"
left[left == FALSE] <- "With parents"
# Divorced living with parents (before divorce)
wp <- bf[(rowSums(bf == 7) > 0 & rowSums(bf == 2) > 0 & rowSums(bf == 3) == 0 &
          rowSums(bf == 5) == 0 & rowSums(bf == 6) == 0) |
         (rowSums(bf == 7) > 0 & rowSums(bf == 4) > 0 & rowSums(bf == 3) == 0 &
         rowSums(bf == 5) == 0 & rowSums(bf == 6) == 0),]
left[rownames(bf) \%in\% rownames(wp) & bf == 7] <- "With parents"

## Building sequence objects
child.seq <- seqdef(children, start = 15)
marr.seq <- seqdef(married, start = 15)
left.seq <- seqdef(left, start = 15)

## Starting values for emission probabilities

# Cluster 1
alphabet(child.seq) # Checking for the order of observed states
B1_child <- matrix(c(0.99, 0.01, # High probability for childless
                     0.99, 0.01,
                     0.99, 0.01,
                     0.99, 0.01), nrow = 4, ncol = 2, byrow = TRUE)

alphabet(marr.seq)
B1_marr <- matrix(c(0.01, 0.01, 0.98, # High probability for single
                    0.01, 0.01, 0.98,
                    0.01, 0.98, 0.01, # High probability for married
                    0.98, 0.01, 0.01), # High probability for divorced
                    nrow = 4, ncol = 3, byrow = TRUE)

alphabet(left.seq)
B1_left <- matrix(c(0.01, 0.99, # High probability for living with parents
                    0.99, 0.01, # High probability for having left home
                    0.99, 0.01,
                    0.99, 0.01), nrow = 4, ncol = 2, byrow = TRUE)

# Cluster 2
B2_child <- matrix(c(0.99, 0.01, # High probability for childless
                     0.99, 0.01,
                     0.99, 0.01,
                     0.01, 0.99), nrow = 4, ncol = 2, byrow = TRUE)

B2_marr <- matrix(c(0.01, 0.01, 0.98, # High probability for single
                    0.01, 0.01, 0.98,
                    0.01, 0.98, 0.01, # High probability for married
                    0.29, 0.7, 0.01),
                   nrow = 4, ncol = 3, byrow = TRUE)

B2_left <- matrix(c(0.01, 0.99, # High probability for living with parents
                    0.99, 0.01,
                    0.99, 0.01,
                    0.99, 0.01), nrow = 4, ncol = 2, byrow = TRUE)

# Cluster 3
B3_child <- matrix(c(0.99, 0.01, # High probability for childless
                     0.99, 0.01,
                     0.01, 0.99,
                     0.99, 0.01,
                     0.01, 0.99,
                     0.01, 0.99), nrow = 6, ncol = 2, byrow = TRUE)

B3_marr <- matrix(c(0.01, 0.01, 0.98, # High probability for single
                    0.01, 0.01, 0.98,
                    0.01, 0.01, 0.98,
                    0.01, 0.98, 0.01,
                    0.01, 0.98, 0.01, # High probability for married
                    0.98, 0.01, 0.01), # High probability for divorced
                   nrow = 6, ncol = 3, byrow = TRUE)

B3_left <- matrix(c(0.01, 0.99, # High probability for living with parents
                    0.99, 0.01,
                    0.50, 0.50,
                    0.01, 0.99,
                    0.99, 0.01,
                    0.99, 0.01), nrow = 6, ncol = 2, byrow = TRUE)

# Initial values for transition matrices
A1 <- matrix(c(0.8,   0.16, 0.03, 0.01,
                 0,    0.9, 0.07, 0.03,
                 0,      0,  0.9,  0.1,
                 0,      0,    0,    1),
             nrow = 4, ncol = 4, byrow = TRUE)

A2 <- matrix(c(0.8, 0.10, 0.05,  0.03, 0.01, 0.01,
                 0,  0.7,  0.1,   0.1, 0.05, 0.05,
                 0,    0, 0.85,  0.01,  0.1, 0.04,
                 0,    0,    0,   0.9, 0.05, 0.05,
                 0,    0,    0,     0,  0.9,  0.1,
                 0,    0,    0,     0,    0,    1),
             nrow = 6, ncol = 6, byrow = TRUE)

# Initial values for initial state probabilities
initial_probs1 <- c(0.9, 0.07, 0.02, 0.01)
initial_probs2 <- c(0.9, 0.04, 0.03, 0.01, 0.01, 0.01)

# Creating covariate swiss
biofam$swiss <- biofam$nat_1_02 == "Switzerland"
biofam$swiss[biofam$swiss == TRUE] <- "Swiss"
biofam$swiss[biofam$swiss == FALSE] <- "Other"

# Build mixture HMM
bMHMM <- buildMixHMM(
  observations = list(child.seq, marr.seq, left.seq),
  transition_matrix = list(A1,A1,A2),
  emission_matrix = list(list(B1_child, B1_marr, B1_left),
                        list(B2_child, B2_marr, B2_left),
                        list(B3_child, B3_marr, B3_left)),
  initial_probs = list(initial_probs1, initial_probs1, initial_probs2),
  formula = ~ sex * birthyr + sex * swiss, data = biofam,
  cluster_names = c("Cluster 1", "Cluster 2", "Cluster 3"),
  channel_names = c("Parenthood", "Marriage", "Left home")
  )

# Fitting the model with different settings

# Only EM with default values
MHMM1 <- fit_mhmm(bMHMM, em_step = TRUE, global_step = FALSE, local_step = FALSE)
MHMM1$logLik # -3081.383

\dontrun{
# EM with LBFGS
MHMM2 <- fit_mhmm(bMHMM, em_step = TRUE, global_step = FALSE, local_step = TRUE)
MHMM2$logLik # -3081.383

# Only LBFGS
MHMM3 <- fit_mhmm(bMHMM, em_step = FALSE, global_step = FALSE, local_step = TRUE,
  local_control = list(maxeval = 5000, maxtime = 0))
MHMM3$logLik # -3087.499373

# Global optimization via MLSL_LDS with LBFGS as local optimizer and final polisher
MHMM4 <- fit_mhmm(bMHMM, em_step = FALSE, global_step = TRUE, local_step = TRUE,
  global_control = list(maxeval = 5000, maxtime = 0))
MHMM4$logLik # -3150.796

# As previously, but now we use ten iterations from EM algorithm for defining initial values and boundaries
# Note smaller maxeval for global optimization
MHMM5 <- fit_mhmm(bMHMM, em_step = TRUE, global_step = TRUE, local_step = TRUE,
  em_control = list(maxeval = 10), global_control = list(maxeval = 1000, maxtime = 0),
  local_control = list(maxeval = 500, maxtime = 0))
MHMM5$logLik #-3081.383
}
# Coefficients of covariates
MHMM1$model$beta

# Probabilities of belonging to each model for the first six subjects
head(MHMM1$model$cluster_prob)
}
}
\seealso{
\code{\link{build_mhmm}} for building MHMMs;
\code{\link{build_hmm}} and \code{\link{fit_hmm}} for building and
  fitting hidden Markov models; \code{\link{plot.mhmm}}
  for plotting \code{mhmm} objects and \code{\link{mssplot}} for plotting
  stacked sequence plots of \code{mhmm} objects.
}

